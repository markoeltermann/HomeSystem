@using System.Globalization
@using ScottPlot
@using ScottPlot.AutoScalers
@using ScottPlot.AxisPanels
@using ScottPlot.Blazor
@using ScottPlot.Palettes
@using ScottPlot.Panels
@using ScottPlot.Plottables
@using SkiaSharp
@using Web.Client.DTOs
@inject NavigationManager navManager
@inject HttpClient http

<div class="row mb-2">
    <div class="col-6 col-xl-3">
        <div class="input-group mb-3">
            <span class="input-group-text">From</span>
            <InputDate TValue="DateTime" @bind-Value=DateFrom @bind-Value:after="SelectedValuesUpdated" class="form-control" />
        </div>
    </div>
    <div class="col-xl-6 col-lg-12 order-5 order-xl-2 d-flex justify-content-between align-items-start">
        <div></div>
        <div class="d-flex flex-column">
            <div>
                <div class="btn-group me-2 chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousMonthClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnMonthClick">Month</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextMonthClick">▷</button>
                </div>
                <div class="btn-group me-2 chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousWeekClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnWeekClick">Week</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextWeekClick">▷</button>
                </div>
                <div class="btn-group chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousDayClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnDayClick">Day</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextDayClick">▷</button>
                </div>
            </div>
            @if (!IsSmall)
            {
                <div class="progress mt-2 loading-bar @(IsLoading ? "" : "invisible")" role="progressbar">
                    <div class="progress-bar progress-bar-striped progress-bar-animated w-100"></div>
                </div>
            }
        </div>
        <button type="button" class="btn chart-button-narrow btn-primary me-2" @onclick="SelectedValuesUpdated">↺</button>
    </div>
    <div class="col-6 col-xl-3 order-2 order-xl-3">
        <div class="input-group mb-3 pe-1">
            <span class="input-group-text">Up&nbsp;to</span>
            <InputDate TValue="DateTime" @bind-Value=DateUpTo @bind-Value:after="SelectedValuesUpdated" class="form-control" />
        </div>
    </div>
</div>
<div class="row">
    <div class="col">
        @if (IsSmall)
        {
            <div class="progress mt-2 loading-bar @(IsLoading ? "" : "invisible")" role="progressbar">
                <div class="progress-bar progress-bar-striped progress-bar-animated w-100"></div>
            </div>
        }
    </div>
</div>
<div class="row flex-grow-1">
    <div class="col pb-2 @(IsSmall ? "" : "ps-4 pe-4")">
        <div class="@(IsSmall ? "small-chart" : "h-100")">
            <BlazorPlotGL @ref="blazorPlot" Style="@chartStyle"></BlazorPlotGL>
        </div>
    </div>
</div>

@code {
    BlazorPlotGL blazorPlot = null!;

    private Plot Plot => blazorPlot.Plot;

    [SupplyParameterFromQuery(Name = "df")]
    public string? DateFromQ { get; set; }

    [SupplyParameterFromQuery(Name = "du")]
    public string? DateUpToQ { get; set; }

    [Parameter]
    public bool IsSmall { get; set; }

    [Parameter]
    public int WindowWidth { get; set; }

    [Parameter]
    public EventCallback Updated { get; set; }

    public DateTime DateFrom { get; set; }

    public DateTime DateUpTo { get; set; }

    public DateTime? SelectedTimestamp { get; set; }

    bool IsLoading { get; set; }

    int generation;
    string chartStyle = "";
    Crosshair? crossHair;
    IPalette? palette;
    bool isHoverLocked;

    private float FontSize => IsSmall ? 10f : 12f;

    private async Task OnPreviousDayClick()
    {
        DateFrom = DateFrom.AddDays(-1);
        DateUpTo = DateUpTo.AddDays(-1);

        await SelectedValuesUpdated();
    }

    private async Task OnNextDayClick()
    {
        DateFrom = DateFrom.AddDays(1);
        DateUpTo = DateUpTo.AddDays(1);

        await SelectedValuesUpdated();
    }

    private async Task OnPreviousWeekClick()
    {
        DateFrom = DateFrom.AddDays(-7);
        DateUpTo = DateUpTo.AddDays(-7);

        await SelectedValuesUpdated();
    }

    private async Task OnNextWeekClick()
    {
        DateFrom = DateFrom.AddDays(7);
        DateUpTo = DateUpTo.AddDays(7);

        await SelectedValuesUpdated();
    }

    private async Task OnPreviousMonthClick()
    {
        DateFrom = DateFrom.AddMonths(-1);
        DateUpTo = DateUpTo.AddMonths(-1);

        await SelectedValuesUpdated();
    }

    private async Task OnNextMonthClick()
    {
        DateFrom = DateFrom.AddMonths(1);
        DateUpTo = DateUpTo.AddMonths(1);

        await SelectedValuesUpdated();
    }

    private async Task OnDayClick()
    {
        DateFrom = DateUpTo = DateTime.Today;
        await SelectedValuesUpdated();
    }

    private async Task OnMonthClick()
    {
        var today = DateTime.Today;
        DateFrom = new DateTime(today.Year, today.Month, 1);
        DateUpTo = DateFrom.AddMonths(1).AddDays(-1);
        await SelectedValuesUpdated();
    }

    private async Task OnWeekClick()
    {
        var today = DateTime.Today;
        DateFrom = today.AddDays(today.DayOfWeek == DayOfWeek.Sunday ? -6 : -((int)today.DayOfWeek - 1));
        DateUpTo = DateFrom.AddDays(6);
        await SelectedValuesUpdated();
    }

    public async Task SelectedValuesUpdated()
    {
        if (Devices.Length == 0)
            return;

        while (blazorPlot?.Plot == null)
        {
            await Task.Delay(100);
        }

        var selectedDevicePointIds = Devices.SelectMany(d => d.Points!.Where(p => p.IsSelected)).Select(d => d.Id).ToArray();
        navManager.NavigateTo(navManager.GetUriWithQueryParameters(new Dictionary<string, object?> {
            { "df", DateFrom.ToString("yyyy-MM-dd") },
            { "du", DateUpTo.ToString("yyyy-MM-dd") },
            { "dpid", selectedDevicePointIds }
        }));
        generation++;

        var currentGeneration = generation;

        var newValues = new List<(DevicePointDto pointDto, string name, ValueContainerDto values)>();

        IsLoading = true;

        var tasks = new List<(DeviceDto, DevicePointDto, Task<ValueContainerDto?>)>();

        foreach (var device in Devices)
        {
            if (device?.Points != null)
            {
                foreach (var point in device.Points.Where(x => x.IsSelected))
                {
                    var id = point.Id;
                    var task = http.GetFromJsonAsync<ValueContainerDto>($"api/devicePoints/{id}/values?from={DateFrom:yyyy-MM-dd}&upTo={DateUpTo:yyyy-MM-dd}");
                    tasks.Add((device, point, task));

                    if (currentGeneration != generation)
                        return;
                }
            }
        }

        if (currentGeneration != generation)
            return;

        foreach (var (device, point, task) in tasks)
        {
            var values = await task;
            newValues.Add((point, device.Name + ": " + point.Name, values!));

            if (currentGeneration != generation)
                return;
        }

        blazorPlot.Plot.Clear<Scatter>();
        blazorPlot.Plot.Clear<Signal>();
        blazorPlot.Plot.Axes.Remove(Edge.Right);

        if (newValues.Any())
        {
            foreach (var (point, _, values) in newValues)
            {
                if (point.Resolution == null || point.Resolution <= 10)
                {
                    var lastWithValue = values.Values.Where(x => x.Value.HasValue || x.StringValue != null).LastOrDefault();
                    if (lastWithValue != null)
                    {
                        SelectedTimestamp = lastWithValue.Timestamp;
                        var index = Array.IndexOf(values.Values, lastWithValue);
                        foreach (var (point2, _, values2) in newValues)
                        {
                            SetSelectedValue(point2, values2, index);
                        }
                        SetCrosshairPosition(lastWithValue.Timestamp);
                        break;
                    }
                }
            }

            var byUnit = newValues.GroupBy(x => x.values.Unit).ToList();
            var unitIndex = 0;
            var seriesIndex = 0;
            foreach (var unitValues in byUnit)
            {
                var isFirstInGroup = true;
                string? firstSeriesName = null;

                IYAxis yAxis;
                if (unitIndex > 0)
                {
                    yAxis = blazorPlot.Plot.Axes.AddRightAxis();
                    if (unitValues.Key == "bool")
                    {
                        yAxis.IsVisible = false;
                    }
                }
                else
                {
                    yAxis = blazorPlot.Plot.Axes.Left;
                }

                if (unitValues.Key == "%")
                {
                    yAxis.Min = 0.0;
                    yAxis.Max = 100.0;
                }
                else
                {
                    yAxis.Range.Reset();
                }
                yAxis.TickLabelStyle.FontSize = FontSize;

                foreach (var (point, name, valueCollection) in unitValues)
                {
                    if (isFirstInGroup)
                        firstSeriesName = name;

                    var color = palette!.GetColor(seriesIndex++);

                    IPlottable? plottable = null;
                    if (valueCollection.Values.All(x => x.Value.HasValue))
                    {
                        var spacing = valueCollection.Values[1].Timestamp.ToOADate() - valueCollection.Values[0].Timestamp.ToOADate();
                        var signal = Plot.Add.Signal(valueCollection.Values.Select(x => x.Value!.Value).ToArray(), spacing, color);
                        signal.Data.XOffset = valueCollection.Values[0].Timestamp.ToOADate();
                        plottable = signal;
                    }
                    else
                    {
                        plottable = blazorPlot.Plot.Add.ScatterLine(valueCollection.Values.Select(x => x.Timestamp).ToArray(),
                            valueCollection.Values.Select(x => x.Value ?? double.NaN).ToArray(),
                            color);
                    }
                    point.Color = color.ToHex();
                    ((IHasLine)plottable).LineStyle.Width = 1.8f;
                    plottable.Axes.YAxis = yAxis;

                    isFirstInGroup = false;
                }

                unitIndex++;
            }

            Values = newValues;

            var xAxis = blazorPlot.Plot.Axes.GetXAxes().First(x => x.Edge == Edge.Bottom);
            xAxis.Min = newValues[0].values.Values[0].Timestamp.ToOADate();
            xAxis.Max = newValues[0].values.Values[^1].Timestamp.ToOADate();
            xAxis.TickLabelStyle.FontSize = FontSize;

            blazorPlot.Plot.MoveToFront(crossHair!);

            isHoverLocked = true;
        }
        else
        {
            Values = new List<(DevicePointDto pointDto, string name, ValueContainerDto values)>();
        }
        IsLoading = false;

        blazorPlot.Refresh();
        await OnUpdated();
    }

    private Task OnUpdated()
    {
        return Updated.InvokeAsync();
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            blazorPlot.Plot.Axes.ContinuouslyAutoscale = false;
            blazorPlot.Plot.Axes.AutoScaler = new FractionalAutoScaler(0, 0.1);
            blazorPlot.Plot.Axes.ContinuousAutoscaleAction = (r) => throw new Exception();

            blazorPlot.Plot.Axes.DateTimeTicksBottom();
            blazorPlot.UserInputProcessor.Disable();

            static string CustomFormatter(DateTime dt)
            {
                bool isMidnight = dt is { Hour: 0, Minute: 0, Second: 0 };
                return isMidnight ? dt.ToString("yyyy-MM-dd") : dt.ToString("HH:mm");
            }

            var tickGen = (ScottPlot.TickGenerators.DateTimeAutomatic)blazorPlot.Plot.Axes.Bottom.TickGenerator;
            tickGen.LabelFormatter = CustomFormatter;

            palette = new Category20();

            crossHair = blazorPlot.Plot.Add.Crosshair(0, 0);
            crossHair.HorizontalLine.IsVisible = false;
            crossHair.VerticalLine.Color = Colors.Gray;
            crossHair.VerticalLine.LabelFontColor = Colors.Black;

            blazorPlot.MouseMoved = async (s, p) =>
            {
                await HandleMouseEvent(p, false);
            };
            blazorPlot.MouseButtonReleased = async (s, p) =>
            {
                await HandleMouseEvent(p.Item1, true);
            };

            crossHair.TextBackgroundColor = Colors.White;
        }

        var height = "99.5%";
        if (IsSmall)
        {
            height = $"{(WindowWidth * 0.7):0}px";
        }
        chartStyle = $"width: 100%; touch-action:pan-y; height: {height};";
        crossHair!.FontSize = FontSize;

        return Task.CompletedTask;
    }

    private async Task HandleMouseEvent(Pixel p, bool isRelease)
    {
        if (!isRelease && isHoverLocked)
            return;

        Pixel mousePixel = new(p.X, p.Y);
        Coordinates mouseCoordinates = blazorPlot.Plot.GetCoordinates(mousePixel);

        if (Values.Any())
        {
            var v = Values[0].values.Values;
            var minX = v[0].Timestamp.ToOADate();
            var maxX = v[^1].Timestamp.ToOADate();
            var index = (int)Math.Round((mouseCoordinates.X - minX) * v.Length / (maxX - minX));
            index = Math.Clamp(index, 0, v.Length - 1);

            SelectedTimestamp = v[index].Timestamp;

            SetCrosshairPosition(v[index].Timestamp);

            foreach (var (point, _, valueContainer) in Values)
            {
                SetSelectedValue(point, valueContainer, index);
            }

            if (isRelease)
            {
                isHoverLocked = !isHoverLocked;
            }

            await OnUpdated();
        }
        else
        {
            crossHair!.IsVisible = false;
            isHoverLocked = false;
        }

        blazorPlot.Refresh();
    }

    private void SetCrosshairPosition(DateTime timestamp)
    {
        crossHair!.VerticalLine.X = timestamp.ToOADate();
        crossHair.VerticalLine.Text = timestamp.ToString("dd HH:mm");
        crossHair.IsVisible = true;
    }

    private void SetSelectedValue(DevicePointDto point, ValueContainerDto values, int index)
    {
        var value = values.Values[index];
        var digits = point.DataTypeName == "Float" ? point.Unit == "EUR/kWh" ? 4 : 1 : 0;
        point.SelectedValue = value.StringValue ?? value.Value?.ToString("F" + digits) ?? "-";
    }

    List<(DevicePointDto pointDto, string name, ValueContainerDto values)> Values { get; set; } = new();

    [Parameter]
    public DeviceDto[] Devices { get; set; } = [];

    protected override async Task OnInitializedAsync()
    {
        if (DateFromQ != null && DateUpToQ != null && TryParseDate(DateFromQ, out var dateFrom) && TryParseDate(DateUpToQ, out var dateUpTo))
        {
            DateFrom = dateFrom;
            DateUpTo = dateUpTo;
        }
        else
        {
            DateFrom = DateUpTo = DateTime.Today;
        }

        await SelectedValuesUpdated();

        bool TryParseDate(string? s, out DateTime d)
            => DateTime.TryParseExact(s, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out d);
    }

    // public class Wrapping : ILegendLayout
    // {
    //     public LegendLayout GetLayout(ScottPlot.Legend legend, LegendItem[] items, PixelSize maxSize)
    //     {
    //         using SKPaint paint = new();
    //         PixelSize maxSizeAfterPadding = maxSize.Contracted(legend.Padding);
    //         PixelRect maxRectAfterPadding = new(0, maxSizeAfterPadding.Width, maxSizeAfterPadding.Height, 0);
    //         PixelSize[] labelSizes = items.Select(x => x.LabelStyle.Measure(x.LabelText, paint).Size).ToArray();
    //         float maxLabelWidth = labelSizes.Select(x => x.Width).Max();
    //         float maxLabelHeight = labelSizes.Select(x => x.Height).Max();
    //         float maxItemWidth = legend.SymbolWidth + legend.SymbolPadding + maxLabelWidth;
    //         float maxItemHeight = maxLabelHeight;

    //         PixelRect[] labelRects = new PixelRect[items.Length];
    //         PixelRect[] symbolRects = new PixelRect[items.Length];

    //         Pixel nextPixel = new(0, 0);
    //         for (int i = 0; i < items.Length; i++)
    //         {
    //             float itemWidth = legend.TightHorizontalWrapping
    //                 ? legend.SymbolWidth + legend.SymbolPadding + labelSizes[i].Width
    //                 : maxItemWidth;

    //             // if the next position will cause an overflow, wrap to the next position
    //             if (legend.Orientation == ScottPlot.Orientation.Horizontal)
    //             {
    //                 if (nextPixel.X + itemWidth > maxSizeAfterPadding.Width)
    //                 {
    //                     nextPixel = new(0, nextPixel.Y + maxItemHeight + legend.InterItemPadding.Bottom);
    //                 }
    //             }
    //             else
    //             {
    //                 if (nextPixel.Y + maxItemHeight > maxSizeAfterPadding.Height)
    //                 {
    //                     nextPixel = new(nextPixel.X + itemWidth + legend.InterItemPadding.Right, 0);
    //                 }
    //             }

    //             // create rectangles for the item using the current position
    //             PixelRect itemRect = new(nextPixel, new PixelSize(itemWidth, maxItemHeight));
    //             itemRect = itemRect.Intersect(maxRectAfterPadding);

    //             symbolRects[i] = new(itemRect.Left, itemRect.Left + legend.SymbolWidth, itemRect.Bottom, itemRect.Top);
    //             labelRects[i] = new(
    //                 left: itemRect.Left + legend.SymbolWidth + legend.SymbolPadding,
    //                 right: itemRect.Right,
    //                 bottom: itemRect.Bottom,
    //                 top: itemRect.Top);

    //             // move the position forward according to the size of this item

    //             if (legend.Orientation == ScottPlot.Orientation.Horizontal)
    //             {
    //                 nextPixel = new(nextPixel.X + itemWidth + legend.InterItemPadding.Right, nextPixel.Y);
    //             }
    //             else
    //             {
    //                 nextPixel = new(nextPixel.X, nextPixel.Y + maxItemHeight + legend.InterItemPadding.Bottom);
    //             }
    //         }

    //         float tightWidth = Math.Min(labelRects.Select(x => x.Right).Max(), maxSizeAfterPadding.Width);
    //         float tightHeight = Math.Min(labelRects.Select(x => x.Bottom).Max(), maxSizeAfterPadding.Height);
    //         PixelRect legendRect = new(0, tightWidth + legend.Padding.Horizontal, tightHeight + legend.Padding.Vertical, 0);
    //         PixelOffset paddingOffset = new(legend.Padding.Left, legend.Padding.Top);

    //         return new LegendLayout
    //         {
    //             LegendItems = items,
    //             LegendRect = legendRect,
    //             LabelRects = labelRects.Select(x => x.WithOffset(paddingOffset)).ToArray(),
    //             SymbolRects = symbolRects.Select(x => x.WithOffset(paddingOffset)).ToArray(),
    //         };
    //     }
    // }
}