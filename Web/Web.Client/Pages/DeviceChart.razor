@using System.Globalization
@using ScottPlot
@using ScottPlot.AutoScalers
@using ScottPlot.AxisPanels
@using ScottPlot.Blazor
@using ScottPlot.Palettes
@using ScottPlot.Panels
@using ScottPlot.Plottables
@using SkiaSharp
@using Web.Client.DTOs
@inject NavigationManager navManager
@inject HttpClient http

<div class="row mb-2">
    <div class="col-6 col-xl-3">
        <div class="input-group mb-3">
            <span class="input-group-text">From</span>
            <InputDate TValue="DateTime" @bind-Value=DateFrom @bind-Value:after="SelectedValuesUpdated" class="form-control" />
        </div>
    </div>
    <div class="col-xl-6 col-lg-12 order-5 order-xl-2 d-flex justify-content-between align-items-start">
        <div></div>
        <div class="d-flex flex-column">
            <div>
                <div class="btn-group me-2 chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousMonthClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnMonthClick">Month</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextMonthClick">▷</button>
                </div>
                <div class="btn-group me-2 chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousWeekClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnWeekClick">Week</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextWeekClick">▷</button>
                </div>
                <div class="btn-group chart-button-wide" role="group">
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnPreviousDayClick">◁</button>
                    <button type="button" class="btn btn-primary" @onclick="OnDayClick">Day</button>
                    <button type="button" class="btn btn-primary chart-button-narrow" @onclick="OnNextDayClick">▷</button>
                </div>
            </div>
            @if (!IsSmall)
            {
                <div class="progress mt-2 loading-bar @(IsLoading ? "" : "invisible")" role="progressbar">
                    <div class="progress-bar progress-bar-striped progress-bar-animated w-100"></div>
                </div>
            }
        </div>
        <button type="button" class="btn chart-button-narrow btn-primary me-2" @onclick="SelectedValuesUpdated">↺</button>
    </div>
    <div class="col-6 col-xl-3 order-2 order-xl-3">
        <div class="input-group mb-3 pe-1">
            <span class="input-group-text">Up&nbsp;to</span>
            <InputDate TValue="DateTime" @bind-Value=DateUpTo @bind-Value:after="SelectedValuesUpdated" class="form-control" />
        </div>
    </div>
</div>
<div class="row">
    <div class="col">
        @if (IsSmall)
        {
            <div class="progress mt-2 loading-bar @(IsLoading ? "" : "invisible")" role="progressbar">
                <div class="progress-bar progress-bar-striped progress-bar-animated w-100"></div>
            </div>
        }
    </div>
</div>
<div class="row flex-grow-1">
    <div class="col pb-2 @(IsSmall ? "" : "ps-4 pe-4")">
        <div class="@(IsSmall ? "small-chart" : "h-100")">
            <BlazorPlotGL @ref="blazorPlot" Style="@chartStyle"></BlazorPlotGL>
        </div>
    </div>
</div>

@code {
    BlazorPlotGL blazorPlot = null!;

    private Plot Plot => blazorPlot.Plot;

    [SupplyParameterFromQuery(Name = "df")]
    public string? DateFromQ { get; set; }

    [SupplyParameterFromQuery(Name = "du")]
    public string? DateUpToQ { get; set; }

    [Parameter]
    public bool IsSmall { get; set; }

    [Parameter]
    public int WindowWidth { get; set; }

    [Parameter]
    public EventCallback Updated { get; set; }

    public DateTime DateFrom { get; set; }

    public DateTime DateUpTo { get; set; }

    public DateTime? SelectedTimestamp { get; set; }

    bool IsLoading { get; set; }

    int generation;
    string chartStyle = "";
    Crosshair? crossHair;
    IPalette? palette;
    bool isHoverLocked;
    private Color axisColor = new Color(0, 0, 0, 32);

    private float FontSize => IsSmall ? 10f : 12f;

    private Dictionary<IYAxis, string> yAxisUnits = new();

    private async Task OnPreviousDayClick()
    {
        DateFrom = DateFrom.AddDays(-1);
        DateUpTo = DateUpTo.AddDays(-1);

        await SelectedValuesUpdated();
    }

    private async Task OnNextDayClick()
    {
        DateFrom = DateFrom.AddDays(1);
        DateUpTo = DateUpTo.AddDays(1);

        await SelectedValuesUpdated();
    }

    private async Task OnPreviousWeekClick()
    {
        DateFrom = DateFrom.AddDays(-7);
        DateUpTo = DateUpTo.AddDays(-7);

        await SelectedValuesUpdated();
    }

    private async Task OnNextWeekClick()
    {
        DateFrom = DateFrom.AddDays(7);
        DateUpTo = DateUpTo.AddDays(7);

        await SelectedValuesUpdated();
    }

    private async Task OnPreviousMonthClick()
    {
        DateFrom = DateFrom.AddMonths(-1);
        DateUpTo = DateUpTo.AddMonths(-1);

        await SelectedValuesUpdated();
    }

    private async Task OnNextMonthClick()
    {
        DateFrom = DateFrom.AddMonths(1);
        DateUpTo = DateUpTo.AddMonths(1);

        await SelectedValuesUpdated();
    }

    private async Task OnDayClick()
    {
        DateFrom = DateUpTo = DateTime.Today;
        await SelectedValuesUpdated();
    }

    private async Task OnMonthClick()
    {
        var today = DateTime.Today;
        DateFrom = new DateTime(today.Year, today.Month, 1);
        DateUpTo = DateFrom.AddMonths(1).AddDays(-1);
        await SelectedValuesUpdated();
    }

    private async Task OnWeekClick()
    {
        var today = DateTime.Today;
        DateFrom = today.AddDays(today.DayOfWeek == DayOfWeek.Sunday ? -6 : -((int)today.DayOfWeek - 1));
        DateUpTo = DateFrom.AddDays(6);
        await SelectedValuesUpdated();
    }

    public async Task SelectedValuesUpdated()
    {
        if (Devices.Length == 0)
            return;

        while (blazorPlot?.Plot == null)
        {
            await Task.Delay(100);
        }

        var selectedDevicePointIds = Devices.SelectMany(d => d.Points!.Where(p => p.IsSelected)).Select(d => d.Id).ToArray();
        navManager.NavigateTo(navManager.GetUriWithQueryParameters(new Dictionary<string, object?> {
            { "df", DateFrom.ToString("yyyy-MM-dd") },
            { "du", DateUpTo.ToString("yyyy-MM-dd") },
            { "dpid", selectedDevicePointIds }
        }));
        generation++;

        var currentGeneration = generation;

        var newValues = new List<(DevicePointDto pointDto, string name, ValueContainerDto values)>();

        IsLoading = true;

        var tasks = new List<(DeviceDto, DevicePointDto, Task<ValueContainerDto?>)>();

        foreach (var device in Devices)
        {
            if (device?.Points != null)
            {
                foreach (var point in device.Points.Where(x => x.IsSelected))
                {
                    var id = point.Id;
                    var task = http.GetFromJsonAsync<ValueContainerDto>($"api/devicePoints/{id}/values?from={DateFrom:yyyy-MM-dd}&upTo={DateUpTo:yyyy-MM-dd}");
                    tasks.Add((device, point, task));

                    if (currentGeneration != generation)
                        return;
                }
            }
        }

        if (currentGeneration != generation)
            return;

        foreach (var (device, point, task) in tasks)
        {
            var values = await task;
            newValues.Add((point, device.Name + ": " + point.Name, values!));

            if (currentGeneration != generation)
                return;
        }

        blazorPlot.Plot.Clear<Scatter>();
        blazorPlot.Plot.Clear<Signal>();
        blazorPlot.Plot.Axes.Remove(Edge.Right);
        foreach (var axis in Plot.Axes.GetYAxes().Where(x => x.Edge == Edge.Left).Skip(1).ToArray())
        {
            Plot.Axes.Remove(axis);
        }

        if (newValues.Any())
        {
            foreach (var (point, _, values) in newValues)
            {
                if (point.Resolution == null || point.Resolution <= 10)
                {
                    var lastWithValue = values.Values.Where(x => x.Value.HasValue || x.StringValue != null).LastOrDefault();
                    if (lastWithValue != null)
                    {
                        SelectedTimestamp = lastWithValue.Timestamp;
                        var index = Array.IndexOf(values.Values, lastWithValue);
                        foreach (var (point2, _, values2) in newValues)
                        {
                            SetSelectedValue(point2, values2, index);
                        }
                        SetCrosshairPosition(lastWithValue.Timestamp);
                        break;
                    }
                }
            }

            var byUnit = newValues.GroupBy(x => x.values.Unit).ToList();
            var unitIndex = 0;
            var seriesIndex = 0;
            foreach (var unitValues in byUnit)
            {
                var isFirstInGroup = true;
                string? firstSeriesName = null;

                IYAxis yAxis;
                if (unitIndex > 0)
                {
                    yAxis = blazorPlot.Plot.Axes.AddRightAxis();
                    if (unitValues.Key == "bool")
                    {
                        yAxis.IsVisible = false;
                    }
                }
                else
                {
                    yAxis = blazorPlot.Plot.Axes.AddLeftAxis();
                }
                yAxis.FrameLineStyle.Color = axisColor;
                yAxis.MajorTickStyle.Color = axisColor;
                yAxis.MinorTickStyle.Color = Colors.Transparent;
                yAxisUnits[yAxis] = unitValues.Key;

                if (unitValues.Key == "%")
                {
                    yAxis.Min = 0.0;
                    yAxis.Max = 100.0;
                }
                else
                {
                    yAxis.Range.Reset();
                }
                yAxis.TickLabelStyle.FontSize = FontSize;

                foreach (var (point, name, valueCollection) in unitValues)
                {
                    if (isFirstInGroup)
                        firstSeriesName = name;

                    var color = palette!.GetColor(seriesIndex++);

                    IPlottable? plottable = null;
                    if (valueCollection.Values.All(x => x.Value.HasValue))
                    {
                        var spacing = valueCollection.Values[1].Timestamp.ToOADate() - valueCollection.Values[0].Timestamp.ToOADate();
                        var signal = Plot.Add.SignalConst(valueCollection.Values.Select(x => x.Value ?? 0.0).ToArray(), spacing, color);
                        signal.Data.XOffset = valueCollection.Values[0].Timestamp.ToOADate();
                        plottable = signal;
                    }
                    else
                    {
                        plottable = blazorPlot.Plot.Add.ScatterLine(valueCollection.Values.Select(x => x.Timestamp).ToArray(),
                            valueCollection.Values.Select(x => x.Value ?? double.NaN).ToArray(),
                            color);
                    }
                    point.Color = color.ToHex();
                    ((IHasLine)plottable).LineStyle.Width = 1.8f;
                    plottable.Axes.YAxis = yAxis;

                    isFirstInGroup = false;
                }

                unitIndex++;
            }

            Values = newValues;

            var xAxis = blazorPlot.Plot.Axes.GetXAxes().First(x => x.Edge == Edge.Bottom);
            xAxis.Min = newValues[0].values.Values[0].Timestamp.ToOADate();
            xAxis.Max = newValues[0].values.Values[^1].Timestamp.ToOADate();
            xAxis.TickLabelStyle.FontSize = FontSize;

            blazorPlot.Plot.MoveToFront(crossHair!);

            isHoverLocked = true;
        }
        else
        {
            Values = new List<(DevicePointDto pointDto, string name, ValueContainerDto values)>();
        }
        IsLoading = false;

        blazorPlot.Refresh();
        await OnUpdated();
    }

    private Task OnUpdated()
    {
        return Updated.InvokeAsync();
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Plot.Axes.ContinuouslyAutoscale = false;
            Plot.Axes.AutoScaler = new FractionalAutoScaler(yAxisUnits);
            Plot.Axes.ContinuousAutoscaleAction = (r) => throw new Exception();

            Plot.Axes.DateTimeTicksBottom();

            Plot.Axes.Top.FrameLineStyle.Color = axisColor;
            Plot.Axes.Bottom.FrameLineStyle.Color = axisColor;
            Plot.Axes.Bottom.MajorTickStyle.Color = axisColor;

            blazorPlot.UserInputProcessor.Disable();

            static string CustomFormatter(DateTime dt)
            {
                bool isMidnight = dt is { Hour: 0, Minute: 0, Second: 0 };
                return isMidnight ? dt.ToString("yyyy-MM-dd") : dt.ToString("HH:mm");
            }

            var tickGen = (ScottPlot.TickGenerators.DateTimeAutomatic)blazorPlot.Plot.Axes.Bottom.TickGenerator;
            tickGen.LabelFormatter = CustomFormatter;

            palette = new Category20();

            crossHair = blazorPlot.Plot.Add.Crosshair(0, 0);
            crossHair.HorizontalLine.IsVisible = false;
            crossHair.VerticalLine.Color = Colors.Gray;
            crossHair.VerticalLine.LabelFontColor = Colors.Black;

            blazorPlot.MouseMoved = async (s, p) =>
            {
                await HandleMouseEvent(p, false);
            };
            blazorPlot.MouseButtonReleased = async (s, p) =>
            {
                await HandleMouseEvent(p.Item1, true);
            };

            crossHair.TextBackgroundColor = Colors.White;

            var leftAxis = Plot.Axes.Left;
            leftAxis.Min = 0;
            leftAxis.Max = 120;
            leftAxis.TickLabelStyle.IsVisible = false;
            leftAxis.IsVisible = false;
            Tick[] ticks = [
                new Tick(10, string.Empty, false),
                new Tick(12, string.Empty, false),
                new Tick(15, string.Empty, true),
                new Tick(20, string.Empty, false),
                new Tick(24, string.Empty, false),
                new Tick(30, string.Empty, true),
                new Tick(36, string.Empty, false),
                new Tick(40, string.Empty, false),
                new Tick(45, string.Empty, true),
                new Tick(48, string.Empty, false),
                new Tick(50, string.Empty, false),
                new Tick(60, string.Empty, true),
                new Tick(70, string.Empty, false),
                new Tick(72, string.Empty, false),
                new Tick(75, string.Empty, true),
                new Tick(84, string.Empty, false),
                new Tick(80, string.Empty, false),
                new Tick(90, string.Empty, true),
                new Tick(96, string.Empty, false),
                new Tick(100, string.Empty, false),
                new Tick(105, string.Empty, true),
                new Tick(108, string.Empty, false),
                new Tick(110, string.Empty, false),
    ];
            leftAxis.TickGenerator = new ScottPlot.TickGenerators.NumericManual(ticks);

            var grid = Plot.Grid;
            grid.YAxisStyle.MinorLineStyle.Width = 1f;
            // grid.YAxisStyle.MinorLineStyle.Pattern = LinePattern.DenselyDashed;
        }

        var height = "99.5%";
        if (IsSmall)
        {
            height = $"{(WindowWidth * 0.7):0}px";
        }
        chartStyle = $"width: 100%; touch-action:pan-y; height: {height};";
        crossHair!.FontSize = FontSize;

        return Task.CompletedTask;
    }

    private async Task HandleMouseEvent(Pixel p, bool isRelease)
    {
        if (!isRelease && isHoverLocked)
            return;

        Pixel mousePixel = new(p.X, p.Y);
        Coordinates mouseCoordinates = blazorPlot.Plot.GetCoordinates(mousePixel);

        if (Values.Any())
        {
            var v = Values[0].values.Values;
            var minX = v[0].Timestamp.ToOADate();
            var maxX = v[^1].Timestamp.ToOADate();
            var index = (int)Math.Floor((mouseCoordinates.X - minX) * v.Length / (maxX - minX));
            index = Math.Clamp(index, 0, v.Length - 1);

            SelectedTimestamp = v[index].Timestamp;

            SetCrosshairPosition(v[index].Timestamp);

            foreach (var (point, _, valueContainer) in Values)
            {
                SetSelectedValue(point, valueContainer, index);
            }

            if (isRelease)
            {
                isHoverLocked = !isHoverLocked;
            }

            await OnUpdated();
        }
        else
        {
            crossHair!.IsVisible = false;
            isHoverLocked = false;
        }

        _ = Task.Run(() => blazorPlot.Refresh());
    }

    private void SetCrosshairPosition(DateTime timestamp)
    {
        crossHair!.VerticalLine.X = timestamp.ToOADate();
        crossHair.VerticalLine.Text = timestamp.ToString("dd HH:mm");
        crossHair.IsVisible = true;
    }

    private void SetSelectedValue(DevicePointDto point, ValueContainerDto values, int index)
    {
        var value = values.Values[index];
        var digits = point.DataTypeName == "Float" ? point.Unit == "EUR/kWh" ? 4 : 1 : 0;
        point.SelectedValue = value.StringValue ?? value.Value?.ToString("F" + digits) ?? "-";
    }

    List<(DevicePointDto pointDto, string name, ValueContainerDto values)> Values { get; set; } = new();

    [Parameter]
    public DeviceDto[] Devices { get; set; } = [];

    protected override async Task OnInitializedAsync()
    {
        if (DateFromQ != null && DateUpToQ != null && TryParseDate(DateFromQ, out var dateFrom) && TryParseDate(DateUpToQ, out var dateUpTo))
        {
            DateFrom = dateFrom;
            DateUpTo = dateUpTo;
        }
        else
        {
            DateFrom = DateUpTo = DateTime.Today;
        }

        await SelectedValuesUpdated();

        bool TryParseDate(string? s, out DateTime d)
            => DateTime.TryParseExact(s, "yyyy-MM-dd", CultureInfo.InvariantCulture, DateTimeStyles.None, out d);
    }

    public class FractionalAutoScaler(Dictionary<IYAxis, string> yAxisUnits) : IAutoScaler
    {
        public bool InvertedX { get; set; }
        public bool InvertedY { get; set; }

        private readonly Dictionary<IYAxis, string> yAxisUnits = yAxisUnits;

        public void AutoScaleAll(IEnumerable<IPlottable> plottables)
        {
            IEnumerable<IXAxis> xAxes = plottables.Select(x => x.Axes.XAxis).Distinct();
            IEnumerable<IYAxis> yAxes = plottables.Select(x => x.Axes.YAxis).Distinct();

            xAxes.ToList().ForEach(x => x.Range.Reset());
            yAxes.ToList().ForEach(x => x.Range.Reset());

            foreach (IPlottable plottable in plottables)
            {
                if (!plottable.IsVisible)
                    continue;

                AxisLimits limits = plottable.GetAxisLimits();
                plottable.Axes.XAxis.Range.Expand(limits.XRange);
                plottable.Axes.YAxis.Range.Expand(limits.YRange);
            }
        }

        public AxisLimits GetAxisLimits(Plot plot, IXAxis xAxis, IYAxis yAxis)
        {
            AxisLimits dataLimits = plot.Axes.GetDataLimits(xAxis, yAxis);
            ExpandingAxisLimits limits = new(dataLimits);

            if (!limits.IsRealX)
            {
                limits.SetX(-10, 10);
            }

            if (!limits.IsRealY)
            {
                limits.SetY(-10, 10);
            }

            if (limits.Left == limits.Right)
            {
                limits.SetX(limits.Left - 1, limits.Right + 1);

                if (limits.Left == limits.Right)
                {
                    limits.Left = NumericConversion.DecrementLargeDouble(limits.Left);
                    limits.Right = NumericConversion.IncrementLargeDouble(limits.Right);
                }
            }

            if (limits.Bottom == limits.Top)
            {
                limits.SetY(limits.Bottom - 1, limits.Top + 1);

                if (limits.Bottom == limits.Top)
                {
                    limits.Bottom = NumericConversion.DecrementLargeDouble(limits.Bottom);
                    limits.Top = NumericConversion.IncrementLargeDouble(limits.Top);
                }
            }

            var r = Math.Pow(10, Round(Math.Log10(limits.VerticalSpan), 0.75) - 1);

            var minY = (int)Math.Floor(limits.Bottom / r);
            var unit = yAxisUnits.GetValueOrDefault(yAxis);
            if (unit == "EUR/kWh" && minY > 0)
            {
                minY = 0;
                r = Math.Pow(10, Math.Round(Math.Log10(limits.Top)) - 1);
            }
            var maxY = (int)Math.Ceiling(limits.Top / r);
            var delta = maxY - minY;

            while (true)
            {
                if ((delta % 3) == 0 || (delta % 4) == 0 || (delta % 5) == 0)
                {
                    break;
                }
                delta++;
            }

            if (delta != (maxY - minY))
            {
                var deltaChange = delta - (maxY - minY);
                if ((deltaChange % 2) == 0)
                {
                    minY -= deltaChange / 2;
                    maxY += deltaChange / 2;
                }
                else
                {
                    minY -= deltaChange / 2;
                    maxY += deltaChange / 2 + 1;
                }
            }

            AxisLimits newLimits = new(
                left: limits.Left,
                right: limits.Right,
                bottom: minY * r,
                top: maxY * r);

            if (!newLimits.IsReal || !newLimits.HasArea)
                throw new InvalidOperationException("limits returned by the autoscaler must always be in a good state");

            return newLimits;
        }

        private double Round(double d, double midpoint)
        {
            if (d >= 0)
            {
                if (d - (int)d < midpoint)
                    return Math.Floor(d);
                else
                    return Math.Ceiling(d);
            }
            else
            {
                if ((int)d - d < midpoint)
                    return Math.Ceiling(d);
                else
                    return Math.Floor(d);
            }
        }
    }


    // public class Wrapping : ILegendLayout
    // {
    //     public LegendLayout GetLayout(ScottPlot.Legend legend, LegendItem[] items, PixelSize maxSize)
    //     {
    //         using SKPaint paint = new();
    //         PixelSize maxSizeAfterPadding = maxSize.Contracted(legend.Padding);
    //         PixelRect maxRectAfterPadding = new(0, maxSizeAfterPadding.Width, maxSizeAfterPadding.Height, 0);
    //         PixelSize[] labelSizes = items.Select(x => x.LabelStyle.Measure(x.LabelText, paint).Size).ToArray();
    //         float maxLabelWidth = labelSizes.Select(x => x.Width).Max();
    //         float maxLabelHeight = labelSizes.Select(x => x.Height).Max();
    //         float maxItemWidth = legend.SymbolWidth + legend.SymbolPadding + maxLabelWidth;
    //         float maxItemHeight = maxLabelHeight;

    //         PixelRect[] labelRects = new PixelRect[items.Length];
    //         PixelRect[] symbolRects = new PixelRect[items.Length];

    //         Pixel nextPixel = new(0, 0);
    //         for (int i = 0; i < items.Length; i++)
    //         {
    //             float itemWidth = legend.TightHorizontalWrapping
    //                 ? legend.SymbolWidth + legend.SymbolPadding + labelSizes[i].Width
    //                 : maxItemWidth;

    //             // if the next position will cause an overflow, wrap to the next position
    //             if (legend.Orientation == ScottPlot.Orientation.Horizontal)
    //             {
    //                 if (nextPixel.X + itemWidth > maxSizeAfterPadding.Width)
    //                 {
    //                     nextPixel = new(0, nextPixel.Y + maxItemHeight + legend.InterItemPadding.Bottom);
    //                 }
    //             }
    //             else
    //             {
    //                 if (nextPixel.Y + maxItemHeight > maxSizeAfterPadding.Height)
    //                 {
    //                     nextPixel = new(nextPixel.X + itemWidth + legend.InterItemPadding.Right, 0);
    //                 }
    //             }

    //             // create rectangles for the item using the current position
    //             PixelRect itemRect = new(nextPixel, new PixelSize(itemWidth, maxItemHeight));
    //             itemRect = itemRect.Intersect(maxRectAfterPadding);

    //             symbolRects[i] = new(itemRect.Left, itemRect.Left + legend.SymbolWidth, itemRect.Bottom, itemRect.Top);
    //             labelRects[i] = new(
    //                 left: itemRect.Left + legend.SymbolWidth + legend.SymbolPadding,
    //                 right: itemRect.Right,
    //                 bottom: itemRect.Bottom,
    //                 top: itemRect.Top);

    //             // move the position forward according to the size of this item

    //             if (legend.Orientation == ScottPlot.Orientation.Horizontal)
    //             {
    //                 nextPixel = new(nextPixel.X + itemWidth + legend.InterItemPadding.Right, nextPixel.Y);
    //             }
    //             else
    //             {
    //                 nextPixel = new(nextPixel.X, nextPixel.Y + maxItemHeight + legend.InterItemPadding.Bottom);
    //             }
    //         }

    //         float tightWidth = Math.Min(labelRects.Select(x => x.Right).Max(), maxSizeAfterPadding.Width);
    //         float tightHeight = Math.Min(labelRects.Select(x => x.Bottom).Max(), maxSizeAfterPadding.Height);
    //         PixelRect legendRect = new(0, tightWidth + legend.Padding.Horizontal, tightHeight + legend.Padding.Vertical, 0);
    //         PixelOffset paddingOffset = new(legend.Padding.Left, legend.Padding.Top);

    //         return new LegendLayout
    //         {
    //             LegendItems = items,
    //             LegendRect = legendRect,
    //             LabelRects = labelRects.Select(x => x.WithOffset(paddingOffset)).ToArray(),
    //             SymbolRects = symbolRects.Select(x => x.WithOffset(paddingOffset)).ToArray(),
    //         };
    //     }
    // }
}